<?php
/**
 * This file is a part of the phpMussel\Core package.
 * Homepage: https://phpmussel.github.io/
 *
 * PHPMUSSEL COPYRIGHT 2013 AND BEYOND BY THE PHPMUSSEL TEAM.
 *
 * License: GNU/GPLv2
 * @see LICENSE.txt
 *
 * This file: The loader (last modified: 2020.07.13).
 */

namespace phpMussel\Core;

class Loader
{
    /**
     * @var string The path to phpMussel's configuration file.
     */
    public $ConfigurationPath = '';

    /**
     * @var array phpMussel's configuration data.
     */
    public $Configuration = [];

    /**
     * @var array phpMussel's configuration defaults.
     */
    public $ConfigurationDefaults = [];

    /**
     * @var string The path to phpMussel's cache data.
     */
    public $CachePath = '';

    /**
     * @var string The path to phpMussel's quarantine.
     */
    public $QuarantinePath = '';

    /**
     * @var string The path to phpMussel's signature files.
     */
    public $SignaturesPath = '';

    /**
     * @var string The path to an optional greylist file.
     */
    public $GreylistPath = '';

    /**
     * @var \Maikuolan\Common\YAML An object for handling YAML data.
     */
    public $YAML;

    /**
     * @var \Maikuolan\Common\Events An object for orchestrating events.
     */
    public $Events;

    /**
     * @var \Maikuolan\Common\L10N An object for handling configuration-defined L10N data.
     */
    public $L10N;

    /**
     * @var \Maikuolan\Common\L10N An object for handling client-defined L10N data.
     */
    public $ClientL10N;

    /**
     * @var string Which client-defined language was accepted by phpMussel (if any).
     */
    public $ClientL10NAccepted = '';

    /**
     * @var \Maikuolan\Common\Cache An object for handling cache data.
     */
    public $Cache;

    /**
     * @var string phpMussel version number (SemVer).
     */
    public $ScriptVersion = '3.0.0-alpha3';

    /**
     * @var string phpMussel version identifier (complete notation).
     */
    public $ScriptIdent = 'phpMussel v%s';

    /**
     * @var string phpMussel user agent (for external requests).
     */
    public $ScriptUA = '%s (https://phpmussel.github.io/)';

    /**
     * @var int When the object was instantiated.
     */
    public $Time = 0;

    /**
     * @var array Used as a soft-cache for just the specific object instance.
     */
    public $InstanceCache = ['LogPaths' => []];

    /**
     * @var array Used for logging any errors generated by phpMussel.
     */
    public $Errors = [];

    /**
     * @var array Contains scan results as human-readable text.
     */
    public $ScanResultsText = [];

    /**
     * @var array Contains scan results as integers.
     */
    public $ScanResultsIntegers = [];

    /**
     * @var string Contains scan results formatted for use by CLI and elsewhere.
     */
    public $ScanResultsFormatted = '';

    /**
     * @var string If the file being scanned happens to be a PE file, references to
     *      the individual PE sections of the files in question will be appended
     *      here.
     */
    public $PEData = '';

    /**
     * @var string Contains references to any files flagged during the scan in the
     *      form of "HASH:FILESIZE:FILENAME".
     */
    public $HashReference = '';

    /**
     * @var bool Set as true at the implementation to enable debug messages.
     */
    public $EnableDebugMessages = false;

    /**
     * @var int Populated by the request method.
     */
    public $MostRecentHttpCode = 0;

    /**
     * @var string The path to the core asset files.
     */
    private $AssetsPath = __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'assets' . DIRECTORY_SEPARATOR;

    /**
     * @var string The path to the core L10N files.
     */
    private $L10NPath = __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'l10n' . DIRECTORY_SEPARATOR;

    /**
     * @var int The default timeout for request.
     */
    private $Timeout = 12;

    /**
     * @var array Channels information for request.
     */
    private $Channels = [];

    /**
     * @var int The default blocksize for readFileBlocks and readFileBlocksGZ.
     */
    private $Blocksize = 131072;

    /**
     * @var string Safety mechanism for logging events.
     */
    const SAFETY = "\x3c\x3fphp die; \x3f\x3e";

    /**
     * Construct the loader.
     *
     * @param string $ConfigurationPath Custom-defined path to phpMussel's
     *      configuration file (optional).
     * @param string $CachePath An optional, custom-defined path to phpMussel's
     *      cache data (this is also where files may be stored temporarily when
     *      it's needed).
     * @param string $QuarantinePath An optional, custom-defined path to
     *      phpMussel's quarantine directory.
     * @param string $SignaturesPath An optional, custom-defined path to
     *      phpMussel's signature files.
     * @param string $VendorPath An optional, custom-defined path to the vendor
     *      directory.
     * @throws Exception if the PHP version requirements aren't met, if the
     *      vendor directory can't be located, or if the phpMussel
     *      configuration file can't be located.
     */
    public function __construct(
        string $ConfigurationPath = '/usr/share/nginx/html/lor/api/laravel/vendor/phpmussel/phpmussel/vault/config.php',
        string $CachePath = '/usr/share/nginx/html/lor/api/laravel/storage/app/public/phpmussel-cache',
        string $QuarantinePath = '/usr/share/nginx/html/lor/api/laravel/storage/app/public/phpmussel-quarantine',
        string $SignaturesPath = '/usr/share/nginx/html/lor/api/laravel/storage/app/public/phpmussel-signatures',
        string $VendorPath = '/usr/share/nginx/html/lor/api/laravel/vendor/'
    ) {
        /** Ensure minimum PHP version requirement is met. */
        if (!version_compare(PHP_VERSION, '7.2.0', '>=')) {
            throw new \Exception('phpMussel v3 requires PHP >= 7.2.0 in order to work properly.');
        }

        /** Fallback to try for undefined VendorPath. */
        if (!$VendorPath) {
            $VendorPath = __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'vendor';
        }

        /** Generate exception if the vendor directory doesn't exist or isn't readable. */
        if (!is_dir($VendorPath) || !is_readable($VendorPath)) {
            throw new \Exception('Vendor directory is undefined or unreadable.');
        }

        /** Prepare the phpMussel version identifier. */
        $this->ScriptIdent = sprintf($this->ScriptIdent, $this->ScriptVersion);

        /** Prepare the phpMussel user agent. */
        $this->ScriptUA = sprintf($this->ScriptUA, $this->ScriptIdent);

        /** Instantiate YAML object. */
        $this->YAML = new \Maikuolan\Common\YAML();

        /** Instantiate events orchestrator. */
        $this->Events = new \Maikuolan\Common\Events();

        /** Needed for referencing. */
        $Errors = &$this->Errors;
        $Events = &$this->Events;

        /**
         * An error handler to catch any errors generated by phpMussel when needed.
         * @link https://php.net/set_error_handler
         *
         * @param int $errno
         * @param string $errstr
         * @param string $errfile
         * @param int $errline
         * @return bool True to end further processing; False to defer processing.
         * @return callable
         */
        set_error_handler(function($errno, $errstr, $errfile, $errline) use (&$Errors, &$Events) {
            $Errors[] = [$errno, $errstr, $errfile, $errline];
            if ($Events->assigned('error')) {
                $Events->fireEvent('error', '', $errno, $errstr, $errfile, $errline);
            }
        });

        /** Calculate configuration path. */
        if ($ConfigurationPath && is_readable($ConfigurationPath)) {
            $this->ConfigurationPath = $ConfigurationPath;
        } elseif ($VendorPath && is_readable($VendorPath . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'phpmussel.ini')) {
            $this->ConfigurationPath = $VendorPath . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'phpmussel.ini';
        } elseif ($VendorPath && is_readable($VendorPath . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'phpmussel.yml')) {
            $this->ConfigurationPath = $VendorPath . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'phpmussel.yml';
        } else {
            throw new \Exception('Unable to locate phpMussel\'s configuration file.');
        }

        /** Read the phpMussel configuration file. */
        if (preg_match('~\.ini$~i', $this->ConfigurationPath)) {
            $this->Configuration = parse_ini_file($this->ConfigurationPath, true);
        } elseif (preg_match('~\.ya?ml$~i', $this->ConfigurationPath)) {
            if ($Configuration = $this->readFile($this->ConfigurationPath)) {
                $this->YAML->process($Configuration, $this->Configuration);
            }
        }

        /** Load phpMussel core configuration defaults and perform fallbacks. */
        if (
            is_readable($this->AssetsPath . 'config.yml') &&
            $Configuration = $this->readFile($this->AssetsPath . 'config.yml')
        ) {
            $Defaults = [];
            $this->YAML->process($Configuration, $Defaults);
            if (isset($Defaults)) {
                $this->fallback($Defaults);
                $this->ConfigurationDefaults = array_merge_recursive($this->ConfigurationDefaults, $Defaults);
            }
        }

        /** Register log paths. */
        $this->InstanceCache['LogPaths'][] = $this->Configuration['core']['scan_log'];
        $this->InstanceCache['LogPaths'][] = $this->Configuration['core']['scan_log_serialized'];
        $this->InstanceCache['LogPaths'][] = $this->Configuration['core']['error_log'];

        /** Calculate and build various paths. */
        foreach (['CachePath', 'QuarantinePath', 'SignaturesPath'] as $Path) {
            if (!$$Path) {
                if (!$VendorPath) {
                    continue;
                }
                $$Path = $VendorPath . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'phpmussel-' . strtolower(substr($Path, 0, -4));
            }
            if (!$this->buildPath($$Path, false)) {
                throw new \Exception(sprint('Unable to build the path, "%s".', $$Path));
            }
            if (($End = substr($$Path, -1)) && $End !== '/' && $End !== '\\') {
                $$Path .= DIRECTORY_SEPARATOR;
            }
            $this->$Path = $$Path;
        }

        /** Failsafe for weird ipaddr configuration and occasional weird server IP handling. */
        if (empty($this->Configuration['core']['ipaddr'])) {
            $this->Configuration['core']['ipaddr'] = 'REMOTE_ADDR';
        }
        if (empty($_SERVER[$this->Configuration['core']['ipaddr']])) {
            $_SERVER[$this->Configuration['core']['ipaddr']] = '';
        }

        /** Set timezone. */
        if (!empty($this->Configuration['core']['timezone']) && $this->Configuration['core']['timezone'] !== 'SYSTEM') {
            date_default_timezone_set($this->Configuration['core']['timezone']);
        }

        /** Calculate instantiation time. */
        $this->Time = time() + ($this->Configuration['core']['time_offset'] * 60);

        /** If the language directive is empty, default to English. */
        if (empty($this->Configuration['core']['lang'])) {
            $this->Configuration['core']['lang'] = 'en';
        }

        /** Load phpMussel core L10N data. */
        $this->loadL10N($this->L10NPath);

        /** Initialise the cache. */
        $this->initialiseCache();

        /**
         * Writes to the default error log.
         *
         * @return bool True on success; False on failure.
         */
        $this->Events->addHandler('final', function (): bool {
            /** Guard. */
            if (
                !isset($this->InstanceCache['PendingErrorLogData']) ||
                !($File = $this->buildPath($this->Configuration['core']['error_log']))
            ) {
                return false;
            }

            if (!file_exists($File) || !filesize($File) || (
                $this->Configuration['core']['truncate'] > 0 &&
                filesize($File) >= $this->readBytes($this->Configuration['core']['truncate'])
            )) {
                $WriteMode = 'wb';
                $Data = $this->L10N->getString('error_log_header') . "\n=====\n" . $this->InstanceCache['PendingErrorLogData'];
            } else {
                $WriteMode = 'ab';
                $Data = $this->InstanceCache['PendingErrorLogData'];
            }

            $Handle = fopen($File, $WriteMode);
            if (is_resource($Handle)) {
                fwrite($Handle, $Data);
                fclose($Handle);
                $this->logRotation($this->Configuration['core']['error_log']);
            }
            return true;
        });

        /**
         * Prepares any caught errors for writing to the default error log.
         *
         * @return bool True on success; False on failure.
         */
        $this->Events->addHandler('error', function (string $Data, array $Err): bool {
            /** Guard. */
            if (!$this->Configuration['core']['error_log']) {
                return false;
            }

            if (!isset($this->InstanceCache['PendingErrorLogData'])) {
                $this->InstanceCache['PendingErrorLogData'] = '';
            }
            $Message = sprintf(
                '[%s] Error at %s:L%d (error code %d)%s.',
                date('c', time()),
                empty($Err[2]) ? '?' : $Err[2],
                empty($Err[3]) ? 0 : $Err[3],
                empty($Err[0]) ? 0 : $Err[0],
                empty($Err[1]) ? '' : ': "' . $Err[1] . '"'
            );
            $this->InstanceCache['PendingErrorLogData'] .= $Message . "\n";
            return true;
        });
    }

    /**
     * Destruct the loader.
     */
    public function __destruct() {
        /** Fire any final shutdown events. */
        if ($this->Events->assigned('final')) {
            $this->Events->fireEvent('final');
        }

        /** Restore default error handler. */
        restore_error_handler();
    }

    /**
     * Returns the content of the specified file (should only use for
     * reasonably small files).
     *
     * @param string $File The file to read.
     * @return string The file's content or an empty string on failure.
     */
    public function readFile(string $File): string
    {
        /** Guard. */
        if (!is_file($File) || !is_readable($File) || !$Filesize = filesize($File)) {
            return '';
        }

        $Handle = fopen($File, 'rb');
        if (!is_resource($Handle)) {
            return '';
        }
        $Data = fread($Handle, $Filesize);
        fclose($Handle);
        return $Data;
    }

    /**
     * Read byte value configuration directives as byte values.
     *
     * @param string $In Input.
     * @param int $Mode Operating mode. 0 for true byte values, 1 for validating.
     * @return string|int Output (return type depends on operating mode).
     */
    public function readBytes(string $In, int $Mode = 0)
    {
        if (preg_match('/[KMGT][oB]$/i', $In)) {
            $Unit = substr($In, -2, 1);
        } elseif (preg_match('/[KMGToB]$/i', $In)) {
            $Unit = substr($In, -1);
        }
        $Unit = isset($Unit) ? strtoupper($Unit) : 'K';
        $In = (float)$In;
        if ($Mode === 1) {
            return $Unit === 'B' || $Unit === 'o' ? $In . 'B' : $In . $Unit . 'B';
        }
        $Multiply = ['K' => 1024, 'M' => 1048576, 'G' => 1073741824, 'T' => 1099511627776];
        return (int)floor($In * (isset($Multiply[$Unit]) ? $Multiply[$Unit] : 1));
    }

    /**
     * Fix incorrect typecasting for some for some variables that sometimes default
     * to strings instead of booleans or integers.
     *
     * @param mixed $Var The variable to fix (passed by reference).
     * @param string $Type The type (or pseudo-type) to cast the variable to.
     */
    public function autoType(&$Var, string $Type = '')
    {
        if (in_array($Type, ['string', 'timezone', 'checkbox', 'url', 'email'], true)) {
            $Var = (string)$Var;
        } elseif ($Type === 'int') {
            $Var = (int)$Var;
        } elseif ($Type === 'float') {
            $Var = (float)$Var;
        } elseif ($Type === 'bool') {
            $Var = (strtolower($Var) !== 'false' && $Var);
        } elseif ($Type === 'kb') {
            $Var = $this->readBytes((string)$Var, 1);
        } else {
            $LVar = strtolower($Var);
            if ($LVar === 'true') {
                $Var = true;
            } elseif ($LVar === 'false') {
                $Var = false;
            } elseif ($Var !== true && $Var !== false) {
                $Var = (int)$Var;
            }
        }
    }

    /**
     * Performs fallbacks and autotyping for missing configuration directives.
     *
     * @param array $Fallbacks The fallback source.
     */
    public function fallback(array $Fallbacks)
    {
        foreach ($Fallbacks as $KeyCat => $DCat) {
            if (!isset($this->Configuration[$KeyCat])) {
                $this->Configuration[$KeyCat] = [];
            }
            if (isset($Cat)) {
                unset($Cat);
            }
            $Cat = &$this->Configuration[$KeyCat];
            if (!is_array($DCat)) {
                continue;
            }
            foreach ($DCat as $DKey => $DData) {
                if (!isset($Cat[$DKey]) && isset($DData['default'])) {
                    $Cat[$DKey] = $DData['default'];
                }
                if (isset($Dir)) {
                    unset($Dir);
                }
                $Dir = &$Cat[$DKey];
                if (isset($DData['value_preg_filter']) && is_array($DData['value_preg_filter'])) {
                    foreach ($DData['value_preg_filter'] as $FilterKey => $FilterValue) {
                        $Dir = preg_replace($FilterKey, $FilterValue, $Dir);
                    }
                }
                if (isset($DData['type'])) {
                    $this->autoType($Dir, $DData['type']);
                }
            }
        }
    }

    /**
     * Load L10N data.
     *
     * @param string $Path Where to find the L10N data to load.
     */
    public function loadL10N(string $Path = '')
    {
        if ($this->Configuration['core']['lang'] === 'en') {
            $Primary = $this->readFile($Path . 'en.yml');
            $Fallback = '';
        } else {
            $Primary = $this->readFile($Path . $this->Configuration['core']['lang'] . '.yml');
            $Fallback = $this->readFile($Path . 'en.yml');
        }
        if ($Primary) {
            $Arr = [];
            $this->YAML->process($Primary, $Arr);
            $Primary = $Arr;
        } else {
            $Primary = [];
        }
        if ($Fallback) {
            $Arr = [];
            $this->YAML->process($Fallback, $Arr);
            $Fallback = $Arr;
        } else {
            $Fallback = [];
        }

        /** Instantiate the L10N object, or append to the instance if it already exists. */
        if ($this->L10N instanceof \Maikuolan\Common\L10N && is_array($this->L10N->Data)) {
            if (!empty($Primary) && is_array($this->L10N->Data)) {
                $this->L10N->Data = array_merge($this->L10N->Data, $Primary);
            }
            if (!empty($Fallback) && is_array($this->L10N->Fallback)) {
                $this->L10N->Fallback = array_merge($this->L10N->Fallback, $Fallback);
            }
        } else {
            $this->L10N = new \Maikuolan\Common\L10N($Primary, $Fallback);
        }

        /** Load client-specified L10N data if possible. */
        if (!$this->Configuration['core']['lang_override'] || empty($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {
            if (!($this->ClientL10N instanceof \Maikuolan\Common\L10N)) {
                $this->ClientL10N = &$L10N;
            }
        } else {
            $Accepted = preg_replace(['~^([^,]*).*$~', '~[^-A-Za-z]~'], ['\1', ''], $_SERVER['HTTP_ACCEPT_LANGUAGE']);
            $Primary = '';
            if (
                $this->Configuration['core']['lang'] !== $Accepted &&
                is_readable($Path . $Accepted . '.yml')
            ) {
                $Primary = $this->readFile($Path . $Accepted . '.yml');
            }
            if (!$Primary) {
                $Accepted = strtolower(preg_replace('~^([^-]*).*$~', '\1', $Accepted));
                if (
                    $this->Configuration['core']['lang'] !== $Accepted &&
                    is_readable($Path . $Accepted . '.yml')
                ) {
                    $Primary = $this->readFile($Path . $Accepted . '.yml');
                }
            }

            /** Process client-specified L10N data. */
            if ($Primary) {
                $Arr = [];
                if (!$this->ClientL10NAccepted) {
                    $this->ClientL10NAccepted = $Accepted;
                }
                $this->YAML->process($Primary, $Arr);
                if ($this->ClientL10N instanceof \Maikuolan\Common\L10N && is_array($this->ClientL10N->Data)) {
                    if (!empty($Primary)) {
                        $this->ClientL10N->Data = array_merge($this->ClientL10N->Data, $Arr);
                    }
                } else {
                    $this->ClientL10N = new \Maikuolan\Common\L10N($Arr, $this->L10N);
                }
            } elseif (!($this->ClientL10N instanceof \Maikuolan\Common\L10N)) {
                $this->ClientL10NAccepted = $Accepted;
                $this->ClientL10N = new \Maikuolan\Common\L10N([], $this->L10N);
            }
        }

        /** Fallback for missing accepted client L10N choice. */
        if (!$this->ClientL10NAccepted) {
            $this->ClientL10NAccepted = $this->Configuration['core']['lang'];
        }
    }

    /**
     * Replaces some date/time symbols with the information they represent.
     *
     * @param int $Time A unix timestamp.
     * @param string|array $In An input or an array of inputs to manipulate.
     * @return string|array The adjusted input(/s).
     */
    public function timeFormat(int $Time, $In)
    {
        /** Guard. */
        if (!is_array($In) && (strpos($In, '{') === false || strpos($In, '}') === false)) {
            return $In;
        }

        $Time = date('dmYHisDMP', $Time);
        $Values = [
            'dd' => substr($Time, 0, 2),
            'mm' => substr($Time, 2, 2),
            'yyyy' => substr($Time, 4, 4),
            'yy' => substr($Time, 6, 2),
            'hh' => substr($Time, 8, 2),
            'ii' => substr($Time, 10, 2),
            'ss' => substr($Time, 12, 2),
            'Day' => substr($Time, 14, 3),
            'Mon' => substr($Time, 17, 3),
            'tz' => substr($Time, 20, 3) . substr($Time, 24, 2),
            't:z' => substr($Time, 20, 6)
        ];
        $Values['d'] = (int)$Values['dd'];
        $Values['m'] = (int)$Values['mm'];
        if (is_array($In)) {
            return array_map(function (string $Item) use (&$Values): string {
                return $this->parse($Values, $Item);
            }, $In);
        }
        return $this->parse($Values, $In);
    }

    /**
     * Replaces encapsulated substrings within a string using the values of the
     * corresponding elements within the supplied array.
     *
     * @param array $Needles An array containing replacement values.
     * @param string $Haystack The string to work with.
     * @return string The string with its encapsulated substrings replaced.
     */
    public function parse(array $Needles, string $Haystack): string
    {
        if (empty($Haystack)) {
            return '';
        }
        foreach ($Needles as $Key => $Value) {
            if (!is_array($Value)) {
                $Haystack = str_replace('{' . $Key . '}', $Value, $Haystack);
            }
        }
        return $Haystack;
    }

    /**
     * Pseudonymise an IP address (reduce IPv4s to /24s and IPv6s to /32s).
     *
     * @param string $IP An IP address.
     * @return string A pseudonymised IP address.
     */
    public function pseudonymiseIP(string $IP): string
    {
        if (($CPos = strpos($IP, ':')) !== false) {
            $Parts = [(substr($IP, 0, $CPos) ?: ''), (substr($IP, $CPos +1) ?: '')];
            if (($CPos = strpos($Parts[1], ':')) !== false) {
                $Parts[1] = substr($Parts[1], 0, $CPos) ?: '';
            }
            $Parts = $Parts[0] . ':' . $Parts[1] . '::x';
            return str_replace(':::', '::', $Parts);
        }
        return preg_replace(
            '/^([01]?\d{1,2}|2[0-4]\d|25[0-5])\.([01]?\d{1,2}|2[0-4]\d|25[0-5])\.([01]?\d{1,2}|2[0-4]\d|25[0-5])\.([01]?\d{1,2}|2[0-4]\d|25[0-5])$/i',
            '\1.\2.\3.x',
            $IP
        );
    }

    /**
     * Build any missing parts of the given path, apply date/time replacements,
     * and check whether the path is writable.
     *
     * @param string $Path The path we're building for.
     * @param bool $PointsToFile Whether the path ultimately points to a file
     *      or a directory.
     * @return string If all missing parts were successfully built and the
     *      final rebuilt path is writable, returns the final rebuilt path.
     *      Otherwise, returns an empty string.
     */
    public function buildPath(string $Path, bool $PointsToFile = true): string
    {
        /** Guard. */
        if (!$Path) {
            return '';
        }

        /** Applies time/date replacements. */
        $Path = $this->timeFormat($this->Time, $Path);

        /** Split path into steps. */
        $Steps = preg_split('~[\\\/]~', $Path, -1, PREG_SPLIT_NO_EMPTY);

        /** Separate file from path. */
        $File = $PointsToFile ? array_pop($Steps) : '';

        /** Build directories. */
        foreach ($Steps as $Step) {
            if (!isset($Rebuilt)) {
                $Rebuilt = preg_match('~^[\\\/]~', $Path) ? DIRECTORY_SEPARATOR . $Step : $Step;
            } else {
                $Rebuilt .= DIRECTORY_SEPARATOR . $Step;
            }
            if (preg_match('~^\.+$~', $Step)) {
                continue;
            }
            if (!is_dir($Rebuilt) && !mkdir($Rebuilt)) {
                return '';
            }
        }

        /** Return an empty string if the final rebuilt path isn't writable. */
        if (!is_writable($Rebuilt)) {
            return '';
        }

        /** Append file. */
        if ($File) {
            $Rebuilt .= ($Rebuilt ? DIRECTORY_SEPARATOR : '') . $File;
        }

        /** Return the final rebuilt path. */
        return $Rebuilt;
    }

    /**
     * Gets substring from haystack prior to the first occurrence of needle.
     *
     * @param string $h The haystack.
     * @param string $n The needle.
     * @return string The substring.
     */
    public function substrBeforeFirst(string $h, string $n): string
    {
        return !$n ? '' : substr($h, 0, strpos($h, $n));
    }

    /**
     * Gets substring from haystack after the first occurrence of needle.
     *
     * @param string $h The haystack.
     * @param string $n The needle.
     * @return string The substring.
     */
    public function substrAfterFirst(string $h, string $n): string
    {
        return !$n ? '' : substr($h, strpos($h, $n) + strlen($n));
    }

    /**
     * Gets substring from haystack prior to the last occurrence of needle.
     *
     * @param string $h The haystack.
     * @param string $n The needle.
     * @return string The substring.
     */
    public function substrBeforeLast(string $h, string $n): string
    {
        return !$n ? '' : substr($h, 0, strrpos($h, $n));
    }

    /**
     * Gets substring from haystack after the last occurrence of needle.
     *
     * @param string $h The haystack.
     * @param string $n The needle.
     * @return string The substring.
     */
    public function substrAfterLast(string $h, string $n): string
    {
        return !$n ? '' : substr($h, strrpos($h, $n) + strlen($n));
    }

    /**
     * Returns the contents of files.
     *
     * @param string $File The file to read.
     * @param int $BlocksToRead The number of blocks to read from the file.
     * @return string The file's contents (an empty string on failure).
     */
    public function readFileBlocks(string $File, int $BlocksToRead = 0): string
    {
        /** Guard. */
        if (!is_file($File) || !is_readable($File) || !$Filesize = filesize($File)) {
            return '';
        }

        /** Calculate this file's blocks to read. */
        if (!$BlocksToRead) {
            $BlocksToRead = ($Filesize && $this->Blocksize) ? ceil($Filesize / $this->Blocksize) : 0;
        }

        $Data = '';
        if ($BlocksToRead > 0) {
            $Handle = fopen($File, 'rb');
            if (!is_resource($Handle)) {
                return '';
            }
            $Done = 0;
            while ($Done < $BlocksToRead) {
                $Data .= fread($Handle, $this->Blocksize);
                $Done++;
            }
            fclose($Handle);
        }
        return $Data;
    }

    /**
     * Returns the contents of GZ-compressed files.
     *
     * @param string $File The file to read.
     * @param int $BlocksToRead The number of blocks to read from the file.
     * @return string The file's contents (an empty string on failure).
     */
    public function readFileBlocksGZ(string $File, int $BlocksToRead = 0): string
    {
        /** Guard. */
        if (!is_file($File) || !is_readable($File) || !$Filesize = filesize($File)) {
            return '';
        }

        /** Calculate this file's blocks to read. */
        if (!$BlocksToRead) {
            $BlocksToRead = ($Filesize && $this->Blocksize) ? ceil($Filesize / $this->Blocksize) : 0;
        }

        $Data = '';
        if ($BlocksToRead > 0) {
            $Handle = gzopen($File, 'rb');
            if (!is_resource($Handle)) {
                return '';
            }
            $Done = 0;
            while (!gzeof($GZLogHandler) && $Done < $BlocksToRead) {
                $Data .= gzread($Handle, $this->Blocksize);
                $Done++;
            }
            gzclose($Handle);
        }
        return $Data;
    }

    /**
     * A simple file() wrapper that checks for the existence of files before
     * attempting to read them, in order to avoid warnings about non-existent
     * files, with a normalised return value.
     *
     * @param string $Filename Refer to the description for file().
     * @param int $Flags Refer to the description for file().
     * @param resource|null $Context Refer to the description for file().
     * @return array The file's contents or an empty array on failure.
     */
    public function readFileAsArray(string $Filename, int $Flags = 0, $Context = null)
    {
        /** Guard. */
        if (!is_file($Filename) || !is_readable($Filename) || !$Filesize = filesize($Filename)) {
            return [];
        }

        if (!is_resource($Context)) {
            $Output = !$Flags ? file($Filename) : file($Filename, $Flags);
        } else {
            $Output = file($Filename, $Flags, $Context);
        }
        return is_array($Output) ? $Output : [];
    }

    /**
     * Used to send cURL requests.
     *
     * @param string $URI The resource to request.
     * @param mixed $Params If empty or omitted, CURLOPT_POST is false. Otherwise,
     *      CURLOPT_POST is true, and the parameter is used to supply
     *      CURLOPT_POSTFIELDS. Normally an associative array of key-value pairs,
     *      but can be any kind of value supported by CURLOPT_POSTFIELDS. Optional.
     * @param int $Timeout An optional timeout limit.
     * @param array $Headers An optional array of headers to send with the request.
     * @param int $Depth Recursion depth of the current closure instance.
     * @return string The results of the request, or an empty string upon failure.
     */
    public function request(string $URI, $Params = [], int $Timeout = -1, array $Headers = [], int $Depth = 0): string
    {
        /** Fetch channel information. */
        if (empty($this->Channels)) {
            $this->Channels = (
                $Channels = $this->readFileBlocks($this->AssetsPath . 'channels.yaml')
            ) ? (new \Maikuolan\Common\YAML($Channels))->Data : [];
            if (!isset($this->Channels['Triggers'])) {
                $this->Channels['Triggers'] = [];
            }
        }

        /** Test channel triggers. */
        foreach ($this->Channels['Triggers'] as $TriggerName => $TriggerURI) {
            if (
                !isset($this->Channels[$TriggerName]) ||
                !is_array($this->Channels[$TriggerName]) ||
                substr($URI, 0, strlen($TriggerURI)) !== $TriggerURI
            ) {
                continue;
            }
            foreach ($this->Channels[$TriggerName] as $Channel => $Options) {
                if (!is_array($Options) || !isset($Options[$TriggerName])) {
                    continue;
                }
                $Len = strlen($Options[$TriggerName]);
                if (substr($URI, 0, $Len) !== $Options[$TriggerName]) {
                    continue;
                }
                unset($Options[$TriggerName]);
                if (empty($Options) || $this->inCsv(key($Options), $this->Configuration['core']['disabled_channels'])) {
                    continue;
                }
                $AlternateURI = current($Options) . substr($URI, $Len);
                break;
            }
            if ($this->inCsv($TriggerName, $this->Configuration['core']['disabled_channels'])) {
                if (isset($AlternateURI)) {
                    return $this->request($AlternateURI, $Params, $Timeout, $Headers, $Depth);
                }
                return '';
            }
            if (isset($this->Channels['Overrides'], $this->Channels['Overrides'][$TriggerName])) {
                $Overrides = $this->Channels['cURL Overrides'][$TriggerName];
            }
            break;
        }

        /** Empty overrides in case none declared. */
        $Overrides = [];

        /** Initialise the cURL session. */
        $Request = curl_init($URI);

        $LCURI = strtolower($URI);
        $SSL = (substr($LCURI, 0, 6) === 'https:');

        curl_setopt($Request, CURLOPT_FRESH_CONNECT, true);
        curl_setopt($Request, CURLOPT_HEADER, false);
        if (empty($Params)) {
            curl_setopt($Request, CURLOPT_POST, false);
            $Post = false;
        } else {
            curl_setopt($Request, CURLOPT_POST, true);
            curl_setopt($Request, CURLOPT_POSTFIELDS, $Params);
            $Post = true;
        }
        if ($SSL) {
            curl_setopt($Request, CURLOPT_PROTOCOLS, CURLPROTO_HTTPS);
            curl_setopt($Request, CURLOPT_SSL_VERIFYPEER, (
                isset($Overrides['CURLOPT_SSL_VERIFYPEER']) ? !empty($Overrides['CURLOPT_SSL_VERIFYPEER']) : false
            ));
        }
        curl_setopt($Request, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($Request, CURLOPT_MAXREDIRS, 1);
        curl_setopt($Request, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($Request, CURLOPT_TIMEOUT, ($Timeout > 0 ? $Timeout : $this->Timeout));
        curl_setopt($Request, CURLOPT_USERAGENT, $this->ScriptUA);
        curl_setopt($Request, CURLOPT_HTTPHEADER, $Headers ?: []);
        $Time = microtime(true);

        /** Execute and get the response. */
        $Response = curl_exec($Request);

        /** Used for debugging. */
        $Time = microtime(true) - $Time;

        /** Check for problems (e.g., resource not found, server errors, etc). */
        if (($Info = curl_getinfo($Request)) && is_array($Info) && isset($Info['http_code'])) {

            /** Used for debugging. */
            $this->debugMessage(sprintf(
                "\r%s - %s - %s - %s\n", $Post ? 'POST' : 'GET', $URI, $Info['http_code'], (floor($Time * 100) / 100) . 's'
            ));

            /** Most recent HTTP code flag. */
            $this->MostRecentHttpCode = $Info['http_code'];

            /** Request failed. Try again using an alternative address. */
            if ($Info['http_code'] >= 400 && isset($AlternateURI) && $Depth < 3) {
                curl_close($Request);
                return $this->request($AlternateURI, $Params, $Timeout, $Headers, $Depth + 1);
            }
        } else {

            /** Used for debugging. */
            $this->debugMessage(sprintf(
                "\r%s - %s - %s - %s\n", $Post ? 'POST' : 'GET', $URI, 200, (floor($Time * 100) / 100) . 's'
            ));

            /** Most recent HTTP code flag. */
            $this->MostRecentHttpCode = 200;
        }

        /** Close the cURL session. */
        curl_close($Request);

        /** Return the results of the request. */
        return $Response;
    }

    /**
     * A simple safety wrapper for unpack.
     *
     * @param string $Format Anything supported by unpack (usually "S" or "*l").
     * @param string $Data The data to be unpacked.
     * @return array The unpacked data (or an empty array upon failure).
     */
    public function unpackSafe(string $Format, string $Data): array
    {
        if (strlen($Data) < 1) {
            return [];
        }
        return unpack($Format, $Data) ?: [];
    }

    /**
     * If input isn't an array, make it so. Remove empty elements.
     *
     * @param mixed $Input
     */
    public function arrayify(&$Input)
    {
        if (!is_array($Input)) {
            $Input = [$Input];
        }
        $Input = array_filter($Input);
    }

    /**
     * GZ-compress a file (used by log rotation).
     *
     * @param string $File The file to GZ-compress.
     * @return bool True on success; False on failure.
     */
    public function gZCompressFile(string $File): bool
    {
        /** Guard. */
        if (!is_file($File) || !is_readable($File)|| !$Filesize = filesize($File)) {
            return false;
        }

        $Handle = fopen($File, 'rb');
        if (!is_resource($Handle)) {
            return false;
        }
        $HandleGZ = gzopen($File . '.gz', 'wb');
        if (!is_resource($HandleGZ)) {
            return false;
        }
        while (!feof($Handle)) {
            $Data = fread($Handle, $this->Blocksize);
            gzwrite($HandleGZ, $Data);
        }
        gzclose($HandleGZ);
        fclose($Handle);
        return true;
    }

    /**
     * Checks whether the specified directory is empty.
     *
     * @param string $Directory The directory to check.
     * @return bool True if empty; False if not empty.
     */
    public function isDirEmpty(string $Directory): bool
    {
        return !((new \FilesystemIterator($Directory))->valid());
    }

    /**
     * Deletes empty directories (used by some front-end methods and log rotation).
     *
     * @param string $Dir The directory to delete.
     */
    public function deleteDirectory(string $Dir)
    {
        while (strrpos($Dir, DIRECTORY_SEPARATOR) !== false) {
            $Dir = substr($Dir, 0, strrpos($Dir, DIRECTORY_SEPARATOR));
            if (!is_dir($Dir) || !$this->isDirEmpty($Dir)) {
                break;
            }
            rmdir($Dir);
        }
    }

    /**
     * Log rotation.
     *
     * @param string $Pattern What to identify logfiles by (should be supplied via the relevant logging directive).
     * @return bool False when log rotation is disabled or errors occur; True otherwise.
     */
    public function logRotation(string $Pattern): bool
    {
        $Limit = $this->Configuration['core']['log_rotation_limit'] ?? 0;
        $Action = $this->Configuration['core']['log_rotation_action'] ?? '';
        if ($Limit < 1 || ($Action !== 'Delete' && $Action !== 'Archive')) {
            return false;
        }
        $Arr = [];
        if ((strpos($Pattern, '{') === false && strpos($Pattern, '}') === false)) {
            if (is_file($Pattern)) {
                $Arr[] = realpath($Pattern);
            }
        } else {
            foreach ($this->resolvePaths($Pattern, true, false) as $Item) {
                $Arr[] = $Item;
            }
        }
        $Files = [];
        foreach ($Arr as $Item) {
            if ($Item && is_file($Item) && is_readable($Item)) {
                $Files[$Item] = filemtime($Item);
            }
        }
        $Count = count($Files);
        $Err = 0;
        if ($Count > $Limit) {
            asort($Files, SORT_NUMERIC);
            foreach ($Files as $Item => $Modified) {
                if ($Action === 'Archive') {
                    $Err += !$this->gZCompressFile($Item);
                }
                $Err += !unlink($Item);
                $this->deleteDirectory($Item);
                $Count--;
                if (!($Count > $Limit)) {
                    break;
                }
            }
        }
        return $Err === 0;
    }

    /**
     * Yield real paths from possible paths using patterns.
     *
     * @param string $Base The path base.
     * @param bool $LastIsFile Whether the last part of the path is a file.
     * @param bool $GZ Whether to append GZ to the pattern.
     * @return \Generator
     */
    public function resolvePaths(string $Base, bool $LastIsFile = true, bool $GZ = true): \Generator
    {
        $Steps = preg_split('~[\\\/]~', $Base, -1, PREG_SPLIT_NO_EMPTY);
        $LastStep = $LastIsFile ? array_pop($Steps) : '';
        $BaseFrom = '';
        $Remainder = '';
        foreach ($Steps as $Step) {
            if (!$Remainder && strpos($Step, '{') === false && strpos($Step, '}') === false) {
                $BaseFrom .= $Step . DIRECTORY_SEPARATOR;
                continue;
            }
            $Remainder .= ($Remainder ? DIRECTORY_SEPARATOR : '') . $Step;
        }
        if (!$BaseFrom || !is_dir($BaseFrom) || !is_readable($BaseFrom)) {
            return;
        }
        if ($Remainder && $LastStep) {
            $LastStep = DIRECTORY_SEPARATOR . $LastStep;
        }
        $Steps = preg_replace(
            ['~\\\{(?:dd|mm|yy|hh|ii|ss)\\\}~i', '~\\\{yyyy\\\}~i', '~\\\{(?:Day|Mon)\\\}~i', '~\\\{tz\\\}~i', '~\\\{t\\\:z\\\}~i'],
            ['\d{2}', '\d{4}', '\w{3}', '.{1,2}\d{4}', '.{1,2}\d{2}\:\d{2}'],
            preg_quote($Remainder) . ($LastStep ? preg_quote($LastStep) . ($GZ ? '(?:\.gz)?' : '') . '$' : '')
        );
        $Pattern = '~^' . preg_quote($BaseFrom) . $Steps . '~i';
        $List = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($BaseFrom), \RecursiveIteratorIterator::SELF_FIRST);
        foreach ($List as $Name => $SplData) {
            if (preg_match($Pattern, $Name) && ($Name = realpath($Name))) {
                yield $Name;
            }
        }
    }

    /**
     * A simple safety wrapper for hex2bin.
     *
     * @param string $Data Hexadecimally encoded data.
     * @return string The decoded data.
     */
    public function hexSafe(string $Data): string
    {
        return ($Data && !preg_match('/[^\da-f]/i', $Data) && !(strlen($Data) % 2)) ? hex2bin($Data) : '';
    }

    /**
     * Initialise the cache.
     *
     * @throws Exception if using flatfiles for caching and if an appropriate
     *      cache directory hasn't been specified or can't be written to.
     */
    private function initialiseCache()
    {
        /** Exit early if already initialised. */
        if ($this->Cache instanceof \Maikuolan\Common\Cache) {
            return;
        }

        /** Create new cache object. */
        $this->Cache = new \Maikuolan\Common\Cache();
        $this->Cache->EnableAPCu = $this->Configuration['supplementary_cache_options']['enable_apcu'];
        $this->Cache->EnableMemcached = $this->Configuration['supplementary_cache_options']['enable_memcached'];
        $this->Cache->EnableRedis = $this->Configuration['supplementary_cache_options']['enable_redis'];
        $this->Cache->EnablePDO = $this->Configuration['supplementary_cache_options']['enable_pdo'];
        $this->Cache->MemcachedHost = $this->Configuration['supplementary_cache_options']['memcached_host'];
        $this->Cache->MemcachedPort = $this->Configuration['supplementary_cache_options']['memcached_port'];
        $this->Cache->RedisHost = $this->Configuration['supplementary_cache_options']['redis_host'];
        $this->Cache->RedisPort = $this->Configuration['supplementary_cache_options']['redis_port'];
        $this->Cache->RedisTimeout = $this->Configuration['supplementary_cache_options']['redis_timeout'];
        $this->Cache->PDOdsn = $this->Configuration['supplementary_cache_options']['pdo_dsn'];
        $this->Cache->PDOusername = $this->Configuration['supplementary_cache_options']['pdo_username'];
        $this->Cache->PDOpassword = $this->Configuration['supplementary_cache_options']['pdo_password'];

        /** Assign cache path. */
        if ($this->CachePath) {
            $this->Cache->FFDefault = $this->CachePath . DIRECTORY_SEPARATOR . 'cache.dat';
        }

        /** Attempt to connect. */
        if (!$this->Cache->connect()) {
            throw new \Exception('Cache connect failed.');
        }
    }

    /**
     * Checks for a value within CSV.
     *
     * @param string $Value The value to look for.
     * @param string $CSV The CSV to look in.
     * @return bool True when found; False when not found.
     */
    public function inCsv(string $Value, string $CSV): bool
    {
        if (!$Value || !$CSV) {
            return false;
        }
        $Arr = explode(',', $CSV);
        if (strpos($CSV, '"') !== false) {
            foreach ($Arr as &$Item) {
                if (substr($Item, 0, 1) === '"' && substr($Item, -1) === '"') {
                    $Item = substr($Item, 1, -1);
                }
            }
        }
        return in_array($Value, $Arr, true);
    }

    /**
     * Prints debug messages (used in dev; not needed for production).
     *
     * @param string $Message The debug message to send.
     */
    public function debugMessage(string $Message)
    {
        if ($this->EnableDebugMessages !== true) {
            return;
        }
        $Handle = fopen('php://stdout', 'wb');
        if (!is_resource($Handle)) {
            return;
        }
        fwrite($Handle, $Message);
        fclose($Handle);
    }

    /**
     * Fetch favicon.
     *
     * @return string The phpMussel favicon (raw PNG data).
     */
    public function getFavicon(): string
    {
        return $this->readFile($this->AssetsPath . 'favicon.png');
    }

    /**
     * Update the configuration.
     *
     * @return bool Whether succeeded or failed.
     */
    public function updateConfiguration(): bool
    {
        if (preg_match('~\.ini$~i', $this->ConfigurationPath)) {
            $Reconstructed = '';
            foreach ($this->Configuration as $CatKey => $CatValue) {
                if (!is_array($CatValue)) {
                    continue;
                }
                $Reconstructed .= sprintf("[%s]\r\n", $CatKey);
                foreach ($CatValue as $DirKey => $DirValue) {
                    if (!is_scalar($DirValue)) {
                        continue;
                    }
                    if ($DirValue === true) {
                        $Reconstructed .= sprintf("%s=true\r\n", $DirKey);
                    } elseif ($DirValue === false) {
                        $Reconstructed .= sprintf("%s=false\r\n", $DirKey);
                    } elseif (is_string($DirValue)) {
                        $Reconstructed .= sprintf("%s='%s'\r\n", $DirKey, $DirValue);
                    } else {
                        $Reconstructed .= sprintf("%s=%s\r\n", $DirKey, $DirValue);
                    }
                }
            }
        } elseif (preg_match('~\.ya?ml$~i', $this->ConfigurationPath)) {
            $Reconstructed = $this->YAML->reconstruct($this->Configuration);
        } else {
            return false;
        }
        $Handle = fopen($this->ConfigurationPath, 'wb');
        if (!is_resource($Handle)) {
            return false;
        }
        $Err = fwrite($Handle, $Reconstructed);
        fclose($Handle);
        return $Err !== false;
    }

    /**
     * Load shorthand data.
     *
     * @return bool Whether succeeded or failed.
     */
    public function loadShorthandData(): bool
    {
        if (isset($this->InstanceCache['shorthand.yml'])) {
            return true;
        }
        if (!$ShorthandData = $this->readFile($this->AssetsPath . 'shorthand.yml')) {
            return false;
        }
        $this->InstanceCache['shorthand.yml'] = [];
        $this->YAML->process($ShorthandData, $this->InstanceCache['shorthand.yml']);
        return true;
    }

    /**
     * Writes to $HashReference, and performs any other needed hit-related actions.
     *
     * @param string $Hash The hash of the item which had a positive hit.
     * @param int $Size The size of the item which had a positive hit.
     * @param string $Name The name of the item which had a positive hit.
     * @param string $Text A human-readable explanation of the hit.
     * @param int $Code The integer results of the scan.
     * @param int $Depth The current depth of the scan process.
     */
    public function atHit(string $Hash, int $Size = -1, string $Name = '', string $Text = '', int $Code = 2, int $Depth = 0)
    {
        /** Fallback for missing item hash. */
        if ($Hash === '') {
            $Hash = $this->L10N->getString('data_not_available');
        }

        /** Fallback for missing item name. */
        if ($Name === '') {
            $Name = $this->L10N->getString('data_not_available');
        }

        /** Ensure that $Text doesn't break lines and clean it up. */
        $Text = preg_replace('~[\x00-\x1f]~', '', $Text);

        /** Generate hash reference and key for various arrays to be populated. */
        $HashReference = sprintf('%s:%d:%s', $Hash, $Size, $Name);
        if (strpos($this->HashReference, $HashReference . "\n") === false) {
            $this->HashReference .= $HashReference . "\n";
        }

        $TextLength = strlen($Text);

        /** Scan results as text. */
        if ($TextLength && isset($this->ScanResultsText[$HashReference]) && strlen($this->ScanResultsText[$HashReference])) {
            $this->ScanResultsText[$HashReference] .= $this->L10N->getString('grammar_spacer') . $Text;
        } else {
            $this->ScanResultsText[$HashReference] = $Text;
        }

        /** Scan results as integers. */
        if (empty($this->ScanResultsIntegers[$HashReference]) || $this->ScanResultsIntegers[$HashReference] !== 2) {
            $this->ScanResultsIntegers[$HashReference] = $Code;
        }

        /** Increment detections count. */
        if ($Code !== 0 && $Code !== 1) {
            if (isset($this->InstanceCache['DetectionsCount'])) {
                $this->InstanceCache['DetectionsCount']++;
            } else {
                $this->InstanceCache['DetectionsCount'] = 1;
            }
        }

        /** Indenting to apply for the formatted scan results . */
        $Indent = str_pad('→ ', ($Depth < 1 ? 4 : ($Depth * 3) + 4), '─', STR_PAD_LEFT);

        /** Fallback for missing text for formatted text. */
        if (!$TextLength) {
            if ($Code === 0) {
                $Text = sprintf(
                    $this->L10N->getString('grammar_exclamation_mark'),
                    sprintf($this->L10N->getString('x_does_not_exist'), $Name)
                );
            } elseif ($Code === 1) {
                $Text = $this->L10N->getString('scan_no_problems_found');
            } else {
                $Text = $this->L10N->getString('data_not_available');
            }
        }

        /** Scan results as formatted text. */
        $this->ScanResultsFormatted .= $Indent . $Text . "\n";

        /** Update flags. */
        $this->InstanceCache['CheckWasLast'] = false;
    }
}
